[{"/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/index.js":"1","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/App.js":"2","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Visualizer.jsx":"3","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/serviceWorker.js":"4","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Visualizer.js":"5","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Toolbar/Toolbar.js":"6","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Grid/Grid.js":"7","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/GRAPH_CONSTANTS.js":"8","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Grid/GRID_CONSTANTS.js":"9","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/bfs.js":"10","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/dijkstraSearch.js":"11","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/recursiveDivisionMaze.js":"12","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/bestFirstSearch.js":"13","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/recursiveMaze.js":"14","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/bestFirstSearchWeighted.js":"15","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/dfs.js":"16","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/dfsMaze.js":"17","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/randomObstructionMaze.js":"18","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Grid/Helper.js":"19","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/NavigationBar/NavigationBar.js":"20","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Legend/Legend.js":"21","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/Utility/utility.js":"22","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/Utility/PriorityQueue.js":"23"},{"size":503,"mtime":1587848077000,"results":"24","hashOfConfig":"25"},{"size":290,"mtime":1587848077000,"results":"26","hashOfConfig":"25"},{"size":4197,"mtime":1610865179967,"results":"27","hashOfConfig":"25"},{"size":5086,"mtime":1587848077000,"results":"28","hashOfConfig":"25"},{"size":565,"mtime":1587848077000,"results":"29","hashOfConfig":"25"},{"size":6739,"mtime":1610873788939,"results":"30","hashOfConfig":"25"},{"size":24115,"mtime":1610871995459,"results":"31","hashOfConfig":"25"},{"size":508,"mtime":1587848077000,"results":"32","hashOfConfig":"25"},{"size":369,"mtime":1587848077000,"results":"33","hashOfConfig":"25"},{"size":2199,"mtime":1587848077000,"results":"34","hashOfConfig":"25"},{"size":4096,"mtime":1587848077000,"results":"35","hashOfConfig":"25"},{"size":3546,"mtime":1587848077000,"results":"36","hashOfConfig":"25"},{"size":2681,"mtime":1587848077000,"results":"37","hashOfConfig":"25"},{"size":2403,"mtime":1587848077000,"results":"38","hashOfConfig":"25"},{"size":2407,"mtime":1587848077000,"results":"39","hashOfConfig":"25"},{"size":1972,"mtime":1587848077000,"results":"40","hashOfConfig":"25"},{"size":3146,"mtime":1587848077000,"results":"41","hashOfConfig":"25"},{"size":1578,"mtime":1587848077000,"results":"42","hashOfConfig":"25"},{"size":1934,"mtime":1587848077000,"results":"43","hashOfConfig":"25"},{"size":1011,"mtime":1587848077000,"results":"44","hashOfConfig":"25"},{"size":213,"mtime":1587848077000,"results":"45","hashOfConfig":"25"},{"size":380,"mtime":1587848077000,"results":"46","hashOfConfig":"25"},{"size":1631,"mtime":1587848077000,"results":"47","hashOfConfig":"25"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"50"},"n6gamn",{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"50"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"50"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"50"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"63","messages":"64","errorCount":0,"warningCount":27,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65","usedDeprecatedRules":"50"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"50"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"50"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"50"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75","usedDeprecatedRules":"50"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"50"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81","usedDeprecatedRules":"50"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84","usedDeprecatedRules":"50"},{"filePath":"85","messages":"86","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"87","usedDeprecatedRules":"50"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"50"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"93","usedDeprecatedRules":"50"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96","usedDeprecatedRules":"50"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"50"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"50"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"50"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107","usedDeprecatedRules":"50"},{"filePath":"108","messages":"109","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"110","usedDeprecatedRules":"50"},"/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/index.js",[],["111","112"],"/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/App.js",["113","114"],"import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport Visualizer from './Visualizer/Toolbar/Toolbar'\nimport Toolbar from './Visualizer/Visualizer';\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Toolbar />\n    </div>\n  );\n}\n\nexport default App;\n","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Visualizer.jsx",[],"/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/serviceWorker.js",[],"/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Visualizer.js",["115"],"import React, {Component} from 'react';\nimport Toolbar from './Toolbar/Toolbar'\nimport Grid from './Grid/Grid';\nexport default class Visualizer extends Component{\n    constructor(props)\n    {\n        super(props);\n        this.state={\n            currentAlgorithm:'',\n            currentAlgrithmKey:-1,\n            algorithms:['Breadth-First-Search','Depth-First-Search','Dijkstra'],\n            mazes:['A','B','C']                \n        };\n    }\n    render()\n    {\n        return (\n            <div>\n                <Grid />\n            </div>\n        );\n    }\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Toolbar/Toolbar.js",["116","117","118","119","120","121","122","123","124","125"],"/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Grid/Grid.js",["126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152"],"import React, {Component} from 'react';\nimport cssClasses from './Grid.module.css';\nimport NavigationBar from '../NavigationBar/NavigationBar';\nimport Toolbar from '../Toolbar/Toolbar';\nimport Legend from '../Legend/Legend';\nimport { UNVISITED,VISITED,PATH,VISITING,OBSTRUCTION,MAX_COLUMN,MAX_ROW,startX,startY,endX,endY,MAZE_SPEED,SEARCH_SPEED } from './GRID_CONSTANTS';\nimport { breadthFirstSearch } from '../algorithms/bfs';\nimport { depthFirstSearch } from '../algorithms/dfs';\nimport { dijkstraSearch } from '../algorithms/dijkstraSearch';\nimport { bestFirstSearch } from '../algorithms/bestFirstSearch';\nimport { bestFirstSearchWeighted } from '../algorithms/bestFirstSearchWeighted';\nimport { recursiveDivisonMaze } from '../algorithms/recursiveDivisionMaze';\nimport { recursiveMaze } from '../algorithms/recursiveMaze';\nimport { dfsMaze } from '../algorithms/dfsMaze';\nimport { randomObstructionMaze } from '../algorithms/randomObstructionMaze';\nimport { createBoard,createWeightBoard,createEmptyWeightBoard } from './Helper';\nexport default class Grid extends Component{\n    constructor(props){\n        super(props);\n        this.state={title: 'Dummy Algorithm',\n        currentAlgorithm:'',\n        disableAll:false,\n        currentAlgorithmKey:-1,\n        algorithms:['BFS','DFS','Swarm','Greedy BFS','A*','Dijkstra'],\n        algorithmFunctions:[this.bfs,this.dfs,this.swarm,this.greedyBFS,this.aStar,this.dijstra],\n        mazes:['Recursive Divison','DFS Maze','Random Connection','Random Obstruction'],\n        mazeFunctions:[this.getRecursiveDivisionMaze,this.getDFSMaze,this.getRecursiveMaze,this.getRandomObstructionMaze],\n        cellsLoaded:false,\n        weightsSet:false\n\n    };\n    }\n    componentDidMount(){\n        this.populateDS();\n    }\n    populateDS=()=>{\n        let result=createBoard();\n        let board,cells;\n        board=result[0];\n        cells=result[1];\n        // let src=board[startX][startY];\n        // let dst=board[endX][endY];\n        this.setState({\n            ...this.state,\n            grid:board,\n            cells:cells,\n            src:board[startY][startX],\n            dst:board[endY][endX]\n        },()=>{\n            this.setState({\n                ...this.state,\n                cellsLoaded:true,\n                cells:cells,\n                setters:{start:{x:this.state.src.i,y:this.state.src.j,settter:this.setSrc},end:{x:this.state.dst.i,y:this.state.dst.j,setter:this.setDst}}\n            });\n        });\n    }\n    tdClickHandler=(key)=>{\n        if(key===this.state.src.key || key===this.state.dst.key || this.state.disableAll==true) return;\n        let cellState=this.state.cells[key].state;\n        this.setState(prevState => {\n            let state = Object.assign({}, prevState);  // creating copy of state variable jasper\n                state.cells[key].state=cellState!==OBSTRUCTION?OBSTRUCTION:UNVISITED;                   // update the name property, assign a new value                 \n                //state.cells[key].className=cssClasses.obstruction;\n            return {state};\n        });\n        if(cellState!==OBSTRUCTION) document.getElementById(key).className=cssClasses.obstruction;\n        else document.getElementById(key).className=cssClasses.unvisited;\n    }\n    setSrc=(i,j)=>{\n        let prevKey=this.state.src.key;\n        if(this.state.grid[i][j].state===OBSTRUCTION)\n        {\n            alert('Cannot place Start here as there is an obstruction, please remove the obstruction first by clicking on the obstructed cell and try again');\n            return;\n        }\n        this.setState({\n            ...this.state,\n            src:this.state.cells[i+'-'+j],\n        });\n        this.clearBoardHandler(true);\n    }\n    setDst=(i,j)=>{\n        let prevKey=this.state.dst.key;\n        if(this.state.grid[i][j].state===OBSTRUCTION)\n        {\n            alert('Cannot place End here as there is an obstruction, please remove the obstruction first by clicking on the obstructed cell and try again');\n            return;\n        }\n        this.setState({dst:this.state.cells[i+'-'+j]});\n        this.clearBoardHandler(true);\n    }\n    componentWillReceiveProps(nextProps) {\n        console.log('^^^^^^^^^%^^^^^^^^^^^^^^^^^^^^^^^^^');\n        this.setState({title: nextProps.title})\n      }\n\n    render()\n    {\n        return (\n            <div>\n                <NavigationBar />\n        <div className=\"card card-block\">\n\n            {/* <h4 className=\"card-title\"><b>title</b></h4>\n\n            <p className=\"card-text\">Some quick example text to build on the card title and make up the bulk of the card's content.</p> */}\n            <Toolbar clear={this.clearBoardHandler} toggleWeights={this.toggleWeights} disableAll={this.state.disableAll} setStart={this.setSrc} setEnd={this.setDst} visualize={this.visualizeSelectedAlgorithmHandler} currentAlgorithm={this.state.currentAlgorithm} algorithms={this.state.algorithms} mazes={this.state.mazes} mazeHandler={this.selectMazeHandler} algorithmHandler={this.selectAlgorithmHandler} />\n            {/* <Legend /> */}\n\n            <div className=\"flex-row\">\n            <table align='center'>\n                <thead>\n                <tr>\n                </tr>\n                </thead>\n                <tbody>\n                    {this.state.cellsLoaded?this.state.grid.map((row,rIndex)=>{\n                        return (\n                            <tr key={rIndex}>\n                            {row.map((cell,cIndex)=>{\n                                return (\n                                <td id={cell.key} key={cell.key} className={cell.state===UNVISITED?cssClasses.unvisited:cell.state===VISITED?cssClasses.visited:cell.state===OBSTRUCTION?cssClasses.obstruction:cell.state==PATH?cssClasses.path:null } onMouseDownCapture={this.tdClickHandler.bind(this,cell.key)}  onDrag={this.tdClickHandler.bind(this,cell.key)}>\n                                    {this.state.src.key===cell.key?<i className=\"fas fa-female\"></i>:this.state.dst.key===cell.key?<i className=\"fa fa-flag\"  aria-hidden=\"true\"></i>:this.state.weightsSet?this.state.weightBoard[rIndex][cIndex]:null}\n                                    </td>\n                                )\n                            })}\n\n                        </tr>\n                        );\n                    }):<tr><td>Loading</td></tr>}\n                </tbody>\n            </table>\n            </div>\n        </div>   \n        </div>     \n        );\n    }\n\n    visualizeSelectedAlgorithmHandler=()=>{\n        if(this.state.currentAlgorithmKey==-1){\n            alert('please select an algorithm first');\n            return;\n        }\n        this.state.algorithmFunctions[this.state.currentAlgorithmKey]();\n    }\n    selectAlgorithmHandler=(key)=>{\n        //alert(key);\n        this.setState({\n            ...this.state,\n            currentAlgorithm:this.state.algorithms[key],\n            currentAlgorithmKey:key\n        });\n        \n    }\n    selectMazeHandler=(key)=>{\n        this.setState({\n            ...this.state,\n            currentMaze:this.state.mazes[key],\n            currentMazeKey:key\n        });\n        this.state.mazeFunctions[key]();\n    }\n    clearBoardHandler=(leaveObstruction)=>{\n        let key,grid,cells,row,x;\n        let board;\n        grid=[];\n        for(var i=0;i<MAX_ROW;i++)\n        {\n            row=[];\n            for(var j=0;j<MAX_COLUMN;j++)\n            {\n                document.getElementById(i+'-'+j).className=cssClasses.unvisited;\n                if(leaveObstruction)\n                {\n                    if(this.state.cells[i+'-'+j].state===OBSTRUCTION) \n                    {\n                        //console.log(i+'-'+j,'obstruction');\n                        this.setState(this.updateCellState(i+'-'+j,OBSTRUCTION,cssClasses.obstruction));\n                        document.getElementById(i+'-'+j).className=cssClasses.obstruction;\n                    }\n                    else \n                    {\n                        //console.log(i+'-'+j,'no-obstruction');\n                        this.setState(this.updateCellState(i+'-'+j,UNVISITED,cssClasses.unvisited));\n                    }\n                }\n                else this.setState(this.updateCellState(i+'-'+j,UNVISITED,cssClasses.unvisited));\n        \n            }\n        }\n        console.log(this.state);\n        }\n        updateCellState=(key,cellState,cssClass)=>{\n        return (prevState)=>{\n            let state = Object.assign({}, prevState);  // creating copy of state variable jasper\n            state.cells[key].state=cellState;                   // update the name property, assign a new value                 \n            //state.cells[key].className=cssClass;\n            return {state};\n            }\n        }\n        \n    getRecursiveMaze=()=>\n    {\n        this.setState({disableAll:true});\n        let currentCell;\n        let newBoard=createBoard();\n        this.clearBoardHandler(false);\n        let board=newBoard[1];\n        let result=recursiveMaze(board,this.state.src,this.state.dst);\n        board=result[0];\n        let visualQueue=result[1];\n        let grid=result[2];\n        var inter=setInterval(()=>{\n            if(visualQueue.length===0)\n            {\n               this.setState({\n                    ...this.state,\n                    cells:board,\n                    src:board[this.state.src.key],\n                    dst:board[this.state.dst.key],\n                    grid:grid,\n                    disableAll:false\n                },()=>{});\n                 \n                clearInterval(inter);\n            }\n            else{\n                currentCell=board[visualQueue.shift()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.obstruction;\n            }\n        },MAZE_SPEED);\n\n    }\n\n    getRandomObstructionMaze=()=>\n    {\n        this.setState({disableAll:true});\n        let currentCell;\n        let newBoard=createBoard();\n        this.clearBoardHandler(false);\n        let board=newBoard[1];\n        let result=randomObstructionMaze(board,this.state.src,this.state.dst);\n        board=result[0];\n        let visualQueue=result[1];\n        let grid=result[2];\n        var inter=setInterval(()=>{\n            if(visualQueue.length===0)\n            {\n               this.setState({\n                    ...this.state,\n                    cells:board,\n                    src:board[this.state.src.key],\n                    dst:board[this.state.dst.key],\n                    grid:grid,\n                    disableAll:false\n                },()=>{});\n                 \n                clearInterval(inter);\n            }\n            else{\n                currentCell=board[visualQueue.shift()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.obstruction;\n            }\n        },MAZE_SPEED);\n\n    }\n\n    getRecursiveDivisionMaze=()=>\n    {\n        this.setState({disableAll:true});\n        let currentCell;\n        let newBoard=createBoard();\n        this.clearBoardHandler(false);\n        let board=newBoard[1];\n        let result=recursiveDivisonMaze(board,this.state.src,this.state.dst);\n        board=result[0];\n        let visualQueue=result[1];\n        let grid=result[2];\n        var inter=setInterval(()=>{\n            if(visualQueue.length===0)\n            {\n               this.setState({\n                    ...this.state,\n                    cells:board,\n                    src:board[this.state.src.key],\n                    dst:board[this.state.dst.key],\n                    grid:grid,\n                    disableAll:false\n                },()=>{});\n                 \n                clearInterval(inter);\n            }\n            else{\n                currentCell=board[visualQueue.shift()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.obstruction;\n            }\n        },MAZE_SPEED);\n\n    }\n\n\n\n\n\n    getDFSMaze=()=>{\n        this.setState({disableAll:true});\n        let currentCell;\n        let newBoard=createBoard();\n        this.clearBoardHandler(false);\n        let board=newBoard[1];\n        let result=dfsMaze(board,this.state.src,this.state.dst);\n        board=result[0];\n        let visualQueue=result[1];\n        let grid=result[2];\n        var inter=setInterval(()=>{\n            if(visualQueue.length===0)\n            {\n               this.setState({\n                    ...this.state,\n                    cells:board,\n                    src:board[this.state.src.key],\n                    dst:board[this.state.dst.key],\n                    grid:grid,\n                    disableAll:false\n                },()=>{});\n                 \n                clearInterval(inter);\n            }\n            else{\n                currentCell=board[visualQueue.shift()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.obstruction;\n            }\n        },MAZE_SPEED);\n    }\n    bfs=()=>{\n        this.setState({disableAll:true});\n        this.clearBoardHandler(true);\n        let board=JSON.parse(JSON.stringify(this.state.cells));\n        let src=board[this.state.src.key];\n        let dst=board[this.state.dst.key];\n        let currentCell,visualQueue,path,grid;\n        let result=breadthFirstSearch(src,board,dst);\n        visualQueue=JSON.parse(JSON.stringify(result[0]));\n        path=JSON.parse(JSON.stringify(result[1]));\n        grid=JSON.parse(JSON.stringify(result[2]));\n        //let stateCells=visualQueue.concat(path);\n        let afterUpdate=()=>{\n        }\n        var inter=setInterval(()=>{\n            if(visualQueue.length===0 && path.length===0) \n            {\n                this.setState({disableAll:false});\n                clearInterval(inter);\n            }\n            else if(visualQueue.length!==0)\n            {\n                currentCell=board[visualQueue.shift()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.visited;\n            }\n            else\n            {\n                currentCell=board[path.pop()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.path;\n            }\n        },SEARCH_SPEED);\n    }\n\n    dfs=()=>{\n        this.setState({disableAll:true});\n        this.clearBoardHandler(true);\n        let board=JSON.parse(JSON.stringify(this.state.cells));\n        let src=board[this.state.src.key];\n        let dst=board[this.state.dst.key];\n        let currentCell,visualQueue,path,grid;\n        let result=depthFirstSearch(src,board,dst);\n        visualQueue=JSON.parse(JSON.stringify(result[0]));\n        path=JSON.parse(JSON.stringify(result[1]));\n        grid=JSON.parse(JSON.stringify(result[2]));\n        //let stateCells=visualQueue.concat(path);\n        let afterUpdate=()=>{\n        }\n        var inter=setInterval(()=>{\n            if(visualQueue.length===0 && path.length===0) \n            {\n                this.setState({disableAll:false});\n                clearInterval(inter);\n            }\n            else if(visualQueue.length!==0)\n            {\n                currentCell=board[visualQueue.shift()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.visited;\n            }\n            else\n            {\n                currentCell=board[path.pop()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.path;\n            }\n        },SEARCH_SPEED);\n    }\n    toggleWeights=()=>{\n        if(!this.state.weightsSet){\n            let weightBoard=createWeightBoard();\n            this.setState({\n                weightsSet:true,\n                weightBoard:weightBoard\n            });\n        }\n        else{\n            this.setState({\n                weightsSet:false,\n                weightBoard:null\n            });\n        }  \n    }\n    createWeights=()=>{\n        let weightBoard=createWeightBoard();\n        this.setState({\n            weightsSet:true,\n            weightBoard:weightBoard\n        });\n    }\n    destroyWeights=()=>{\n        this.setState({\n            weightsSet:false,\n            weightBoard:null\n        });\n    }\n    dijstra=()=>{\n        this.setState({disableAll:true});\n        this.clearBoardHandler(true);\n        let board=JSON.parse(JSON.stringify(this.state.cells));\n        let src=board[this.state.src.key];\n        let dst=board[this.state.dst.key];\n        let weights;\n        let currentCell,visualQueue,path,grid;\n        \n        let result;\n        if(this.state.weightsSet) weights=this.state.weightBoard;            \n        else weights=createEmptyWeightBoard();\n        result=dijkstraSearch(src,board,dst,weights);        \n        visualQueue=JSON.parse(JSON.stringify(result[0]));\n        path=JSON.parse(JSON.stringify(result[1]));\n        grid=JSON.parse(JSON.stringify(result[2]));\n        //let stateCells=visualQueue.concat(path);\n        let afterUpdate=()=>{\n        }\n        var inter=setInterval(()=>{\n            if(visualQueue.length===0 && path.length===0) \n            {\n                this.setState({disableAll:false});\n                clearInterval(inter);\n            }\n            else if(visualQueue.length!==0)\n            {\n                currentCell=board[visualQueue.shift()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.visited;\n            }\n            else\n            {\n                currentCell=board[path.pop()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.path;\n            }\n        },SEARCH_SPEED);\n    }\n    aStar=()=>{\n\n        this.setState({disableAll:true});\n        this.clearBoardHandler(true);\n        let board=JSON.parse(JSON.stringify(this.state.cells));\n        let src=board[this.state.src.key];\n        let dst=board[this.state.dst.key];\n        let currentCell,visualQueue,path,grid;\n        let heuristic,row;\n        let result;\n        heuristic=[];\n        for(var r=0;r<MAX_ROW;r++){\n            row=[];            //f(a)=g(a)+h(a)  //destination heuristics                    //source heuristics \n            for(var c=0;c<MAX_COLUMN;c++) row.push(Math.abs(r-dst.i)+Math.abs(c-dst.j)         +Math.abs(r-src.i)+Math.abs(c-src.j)/2        ); //manhatten distance\n            heuristic.push(row);\n        }\n        if(this.state.weightsSet)\n        {\n            let weights=this.state.weightBoard\n            result=bestFirstSearchWeighted(src,board,dst,heuristic,weights);\n        }\n        else result=bestFirstSearch(src,board,dst,heuristic);\n\n        visualQueue=JSON.parse(JSON.stringify(result[0]));\n        path=JSON.parse(JSON.stringify(result[1]));\n        grid=JSON.parse(JSON.stringify(result[2]));\n        //let stateCells=visualQueue.concat(path);\n        let afterUpdate=()=>{\n        }\n        var inter=setInterval(()=>{\n            if(visualQueue.length===0 && path.length===0) \n            {\n                this.setState({disableAll:false});\n                clearInterval(inter);\n            }\n            else if(visualQueue.length!==0)\n            {\n                currentCell=board[visualQueue.shift()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.visited;\n            }\n            else\n            {\n                currentCell=board[path.pop()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.path;\n            }\n        },SEARCH_SPEED);\n    }\n    greedyBFS=()=>{\n\n        this.setState({disableAll:true});\n        this.clearBoardHandler(true);\n        let board=JSON.parse(JSON.stringify(this.state.cells));\n        let src=board[this.state.src.key];\n        let dst=board[this.state.dst.key];\n        let currentCell,visualQueue,path,grid;\n        let result;\n        let heuristic,row;\n        heuristic=[];\n        for(var r=0;r<MAX_ROW;r++){\n            row=[];\n            for(var c=0;c<MAX_COLUMN;c++){ //f(a)=h(a)\n                row.push(Math.abs(r-dst.i)+Math.abs(c-dst.j)); //manhatten distance\n            }\n            heuristic.push(row);\n        }\n        if(this.state.weightsSet){\n            let weights=this.state.weightBoard\n            result=bestFirstSearchWeighted(src,board,dst,heuristic,weights);\n        }\n        else result=bestFirstSearch(src,board,dst,heuristic);\n        visualQueue=JSON.parse(JSON.stringify(result[0]));\n        path=JSON.parse(JSON.stringify(result[1]));\n        grid=JSON.parse(JSON.stringify(result[2]));\n        //let stateCells=visualQueue.concat(path);\n        let afterUpdate=()=>{\n        }\n        var inter=setInterval(()=>{\n            if(visualQueue.length===0 && path.length===0) \n            {\n                this.setState({disableAll:false});\n                clearInterval(inter);\n            }\n            else if(visualQueue.length!==0)\n            {\n                currentCell=board[visualQueue.shift()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.visited;\n            }\n            else\n            {\n                currentCell=board[path.pop()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.path;\n            }\n        },SEARCH_SPEED);\n\n    }\n\n    swarm=()=>{\n\n        this.setState({disableAll:true});\n        this.clearBoardHandler(true);\n        let board=JSON.parse(JSON.stringify(this.state.cells));\n        let src=board[this.state.src.key];\n        let dst=board[this.state.dst.key];\n        let currentCell,visualQueue,path,grid;\n        let heuristic,row;\n        let result;\n        heuristic=[];\n        for(var r=0;r<MAX_ROW;r++){\n            row=[];            //f(a)=g(a)+h(a)  //destination heuristics                    //source heuristics \n            for(var c=0;c<MAX_COLUMN;c++) row.push(Math.abs(r-dst.i)+Math.abs(c-dst.j)         +Math.abs(r-src.i)+Math.abs(c-src.j)/2        ); //manhatten distance\n            heuristic.push(row);\n        }\n        if(this.state.weightsSet)\n        {\n            let weights=this.state.weightBoard;\n            for(var r=0;r<MAX_ROW;r++){\n                //row=[];            //f(a)=g(a)+h(a)  //destination heuristics                    //source heuristics \n                for(var c=0;c<MAX_COLUMN;c++) heuristic[r][c]+=weights[r][c]; //manhatten distance\n                //heuristic.push(row);\n            }    \n            result=dijkstraSearch(src,board,dst,heuristic);\n        }\n        else result=dijkstraSearch(src,board,dst,heuristic);\n\n        visualQueue=JSON.parse(JSON.stringify(result[0]));\n        path=JSON.parse(JSON.stringify(result[1]));\n        grid=JSON.parse(JSON.stringify(result[2]));\n        //let stateCells=visualQueue.concat(path);\n        let afterUpdate=()=>{\n        }\n        var inter=setInterval(()=>{\n            if(visualQueue.length===0 && path.length===0) \n            {\n                this.setState({disableAll:false});\n                clearInterval(inter);\n            }\n            else if(visualQueue.length!==0)\n            {\n                currentCell=board[visualQueue.shift()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.visited;\n            }\n            else\n            {\n                currentCell=board[path.pop()];\n                //this.setState(updateState,afterUpdate);\n                document.getElementById(currentCell.key).className=cssClasses.path;\n            }\n        },SEARCH_SPEED);\n    }\n\n\n\n\n\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/GRAPH_CONSTANTS.js",[],"/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Grid/GRID_CONSTANTS.js",[],"/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/bfs.js",["153","154"],"import { VISITED,OBSTRUCTION,UNVISITED,PATH, MAX_COLUMN, MAX_ROW } from './GRAPH_CONSTANTS';\nexport function breadthFirstSearch(src,board,dst)\n{\n    // console.log('src',src);\n    // console.log('dst',dst);\n    // console.log('board',board);\n    let currentCell,i,j,hashKey;\n    let queue=[];\n    let visualQueue=[];\n    let previous={};\n    let result=[];\n    let r=[-1,0,1,0]; //x,y x-1,y x+1,y x,y-1 x,y+1\n    let c=[0,-1,0,1];\n    // console.log('src:',src);\n    // console.log('dst:',dst);\n    // console.log('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')\n    queue.push(src);\n    while(queue.length!=0)\n    {\n        currentCell=queue.shift();\n        if(currentCell.state===VISITED) continue;\n        if(currentCell.key===dst.key)\n        {\n            visualQueue.push(currentCell.key);\n            currentCell.state=VISITED;\n            break;\n        }\n        currentCell.state=VISITED;\n        //currentCell.className=cssClasses.visited;\n        visualQueue.push(currentCell.key);\n        for(let a=0;a<r.length;a++) //or c.length\n        {\n            i=currentCell.i+r[a];\n            j=currentCell.j+c[a];\n            hashKey=i+'-'+j;\n            if(board[hashKey] && board[hashKey].state===UNVISITED)\n            {\n                queue.push(board[hashKey]);\n                previous[hashKey]=currentCell.i+'-'+currentCell.j;\n            }\n        }\n    }\n    let node=dst.key;\n    let path=[];\n    while(1)\n    {\n        if(node)\n        {\n            path.push(node);\n            board[node].state=PATH;\n            node=previous[node];\n            // console.log(node);\n            if(node===src.key)\n            {\n                path.push(node);\n                board[node].state=PATH;\n                break;\n            }\n        }\n        else break;\n    }\n    let grid=getGrid(board);\n    result=[visualQueue,path,grid];\n    // console.log('path',path);\n    // console.log('visualQueue',visualQueue);\n    return result;\n}\nfunction getGrid(board)\n{\n    let grid,row;\n    grid=[];\n    for(var i=0;i<MAX_ROW;i++)\n    {\n        row=[]\n        for(var j=0;j<MAX_COLUMN;j++)\n        {\n            row.push(board[i+'-'+j]);\n        }\n        grid.push(row);\n    }\n    return grid;\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/dijkstraSearch.js",["155","156","157","158","159","160","161","162","163","164"],"import { VISITED,OBSTRUCTION,UNVISITED,PATH, MAX_COLUMN, MAX_ROW } from './GRAPH_CONSTANTS';\n//import { PriorityQueue } from './Utility/PriorityQueue';\nimport { getGrid } from './Utility/utility';\nexport function dijkstraSearch(src,board,dst,weightsBoard)\n{\nconst pq=new PriorityQueue((a,b)=>{return a[0]<b[0]});\n// console.log('src',src);\n// console.log('dst',dst);\n// console.log('board',board);\nlet currentCell,i,j,hashKey,pathWeight,weight;\nlet visualQueue=[];\nlet previous={};\nlet next={};\nlet result=[];\nlet weights={};\nlet visited={};\n\nlet grid=getGrid(board);\n\nlet neighbour;\nlet r=[-1,0,1,0]; //x,y x-1,y x+1,y x,y-1 x,y+1\nlet c=[0,-1,0,1];\n// console.log('src:',src);\n// console.log('dst:',dst);\n// console.log('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')\npq.push([0,src]);\n\n\nwhile(!pq.isEmpty())\n{\n    currentCell=pq.pop();\n    //visited[currentCell.i+'-'+currentCell.j]\n    if(currentCell[1].state==VISITED) continue;\n    currentCell[1].state=VISITED;\n    visualQueue.push(currentCell[1].key);\n    //weights[currentCell.i+'-'+currentCell.j]=currentCell;\n    if(currentCell[1].key==dst.key) break;\n    for(let a=0;a<r.length;a++){ // or c.length\n        i=currentCell[1].i+r[a];\n        j=currentCell[1].j+c[a];\n        //console.log('grid error',currentCell[1].i+r[a]);\n        if(i<0 || i>=MAX_ROW || j<0 || j>=MAX_COLUMN) continue;\n        neighbour=grid[currentCell[1].i+r[a]][currentCell[1].j+c[a]];\n        if(!neighbour)\n        {\n          console.log('error:',currentCell[1].i+r[a],currentCell[1].j+c[a]);\n          //continue;\n        }\n        if(neighbour.state==VISITED || neighbour.state==OBSTRUCTION) continue;\n        pathWeight=currentCell[0]+weightsBoard[neighbour.i][neighbour.j]\n        pq.push([pathWeight,neighbour]);\n        weight=previous[neighbour.key]?previous[neighbour.key][0]:Infinity;\n        if(weight>pathWeight) previous[neighbour.key]=[pathWeight,currentCell[1].key];\n    }\n\n}\n\nconsole.log(previous);\n\nlet node=dst.key;\nlet path=[];\nwhile(1)\n{\n    if(node)\n    {\n        path.push(node);\n        board[node].state=PATH;\n        if(!previous[node]) break;\n        node=previous[node][1];\n        console.log(node);\n        if(node===src.key)\n        {\n            path.push(node);\n            board[node].state=PATH;\n            break;\n        }\n    }\n    else break;\n}\n\n\n\nresult=[visualQueue,path,grid];\nconsole.log('path',path);\nconsole.log('visualQueue',visualQueue);\nreturn result;\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst top = 0;\nconst parent = i => ((i + 1) >>> 1) - 1;\nconst left = i => (i << 1) + 1;\nconst right = i => (i + 1) << 1;\n\nexport default class PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this._heap = [];\n    this._comparator = comparator;\n  }\n  size() {\n    return this._heap.length;\n  }\n  isEmpty() {\n    return this.size() == 0;\n  }\n  peek() {\n    return this._heap[top];\n  }\n  push(...values) {\n    values.forEach(value => {\n      this._heap.push(value);\n      this._siftUp();\n    });\n    return this.size();\n  }\n  pop() {\n    const poppedValue = this.peek();\n    const bottom = this.size() - 1;\n    if (bottom > top) {\n      this._swap(top, bottom);\n    }\n    this._heap.pop();\n    this._siftDown();\n    return poppedValue;\n  }\n  replace(value) {\n    const replacedValue = this.peek();\n    this._heap[top] = value;\n    this._siftDown();\n    return replacedValue;\n  }\n  _greater(i, j) {\n    return this._comparator(this._heap[i], this._heap[j]);\n  }\n  _swap(i, j) {\n    [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];\n  }\n  _siftUp() {\n    let node = this.size() - 1;\n    while (node > top && this._greater(node, parent(node))) {\n      this._swap(node, parent(node));\n      node = parent(node);\n    }\n  }\n  _siftDown() {\n    let node = top;\n    while (\n      (left(node) < this.size() && this._greater(left(node), node)) ||\n      (right(node) < this.size() && this._greater(right(node), node))\n    ) {\n      let maxChild = (right(node) < this.size() && this._greater(right(node), left(node))) ? right(node) : left(node);\n      this._swap(node, maxChild);\n      node = maxChild;\n    }\n  }\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/recursiveDivisionMaze.js",["165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180"],"import { VISITED,OBSTRUCTION,UNVISITED, MAX_COLUMN,MAX_ROW, MAZE } from './GRAPH_CONSTANTS';\nexport function recursiveDivisonMaze(board,src,dst)\n{\nlet grid=getGrid(board);\nlet visited=generateVisited();\nlet visualQueue;\n//visited[src.i][src.j]=true;\n//visited[dst.i][dst.j]=true;\n\nvisualQueue=dfs(board,MAZE.x,MAZE.y,visited,src,dst);\nlet result=[board,visualQueue,grid];\nreturn result;\n}\nfunction dfs(board,i,j,visited,src,dst)\n{\n    let visualQueue=[];\n    for(var x=0;x<MAX_ROW;x++) addToQueue(x,0,board,visualQueue,src,dst);\n    for(var y=0;y<MAX_COLUMN;y++) addToQueue(MAX_ROW-1,y,board,visualQueue,src,dst);\n    for(var x=MAX_ROW-1;x>=0;x--) addToQueue(x,MAX_COLUMN-1,board,visualQueue,src,dst);\n    for(var y=MAX_COLUMN-1;y>=0;y--) addToQueue(0,y,board,visualQueue,src,dst);    \n    let minI,minJ,maxI,maxJ,mid,mid1,mid2,opening;\n    minJ=minI=2;\n    maxI=MAX_ROW-2-1;\n    maxJ=MAX_COLUMN-2-1;\n    let stack=[];\n    stack.push([minI,minJ,maxI,maxJ,true]);\n    //addToQueue(i,j,board,visualQueue,src,dst)\n    visited[i][j]=true;\n    let currentNode,counter;\n    counter=0;\n    while(stack.length!=0)\n    {\n        //if(counter==10) break; \n        //counter++;\n        if(stack.length==100) break;\n        currentNode=stack.pop();\n        minI=currentNode[0];\n        minJ=currentNode[1];\n        maxI=currentNode[2];\n        maxJ=currentNode[3];\n        console.log('currentNode:',currentNode);\n        if(currentNode[4]){\n            if(maxI-minI<2) continue;\n            mid=Math.floor(randomNumber(minJ, maxJ)/2)*2;\n            createVertical(minI,maxI,mid,board,visualQueue,src,dst);\n            stack.push([minI,minJ,maxI,mid-1,!currentNode[4]]);\n            stack.push([minI,mid+1,maxI,maxJ,!currentNode[4]]);\n        }\n        else{\n            if(maxJ-minJ<2) continue;\n            mid=Math.floor(randomNumber(minI,maxI)/2)*2;\n            createHorizontal(minJ,maxJ,mid,board,visualQueue,src,dst);\n            stack.push([minI,minJ,mid-1,maxJ,!currentNode[4]]);\n            stack.push([mid+1,minJ,maxI,maxJ,!currentNode[4]]);\n        }\n    \n    }\n    return visualQueue;\n}\nfunction createHorizontal(minJ,maxJ,mid,board,visualQueue,src,dst)\n{\n    let hole=Math.floor(randomNumber(minJ,maxJ)/2)*2+1;\n    for(var x=minJ;x<=maxJ;x++){\n        if(x==hole) continue;\n        else addToQueue(mid,x,board,visualQueue,src,dst);\n    }\n}\nfunction createVertical(minI,maxI,mid,board,visualQueue,src,dst){\n    let hole=Math.floor(randomNumber(minI,maxI)/2)*2+1;\n    for(var x=minI;x<=maxI;x++){\n        if(x==hole) continue;\n        else addToQueue(x,mid,board,visualQueue,src,dst);\n    }\n}\n\n\nfunction addToQueue(i,j,board,visualQueue,src,dst)\n{\nif((i==src.i && j==src.j) || (i==dst.i && j==dst.j)) return;\nlet key=i+'-'+j;\n//console.log(key);\nif(!board[key]){\n    console.log('2222222222222222      '+key);\n    return;\n}\nboard[key].state=OBSTRUCTION;\nvisualQueue.push(key);\n//board[key].className='cssClasses.obstruction';\n}\n\nfunction randomNumber(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n\nfunction getGrid(board)\n{\n    let grid,row;\n    grid=[];\n    for(var i=0;i<MAX_ROW;i++)\n    {\n        row=[]\n        for(var j=0;j<MAX_COLUMN;j++)\n        {\n            row.push(board[i+'-'+j]);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\nfunction generateVisited(){\n    let visited,row;\n    visited=[];\n    for(var i=0;i<MAX_ROW;i++)\n    {\n        row=[]\n        for(var j=0;j<MAX_COLUMN;j++)\n        {\n            row.push(false);\n        }\n        visited.push(row);\n    }\n    return visited;    \n}\n","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/bestFirstSearch.js",["181"],"import { VISITED,OBSTRUCTION,UNVISITED,PATH, MAX_COLUMN, MAX_ROW } from './GRAPH_CONSTANTS';\nimport PriorityQueue from './Utility/PriorityQueue';\nexport function bestFirstSearch(src,board,dst,heuristics)\n{\n    // console.log('src',src);\n    // console.log('dst',dst);\n    // console.log('board',board);\n    let z,currentCell,i,j,hashKey;\n    let queue=new PriorityQueue((a,b)=>{return a[0]<b[0];});\n    let visualQueue=[];\n    let previous={};\n    let result=[];\n    let r=[-1,0,1,0]; //x,y x-1,y x+1,y x,y-1 x,y+1\n    let c=[0,-1,0,1];\n    // console.log('src:',src);\n    // console.log('dst:',dst);\n    // console.log('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')\n    queue.push([heuristics[src.i][src.j],src]);\n    while(!queue.isEmpty())\n    {\n        z=queue.pop();\n        // if(!z)\n        // {\n        //     console.log(queue.length())\n        //     continue;\n        // }\n        console.log(z);\n        currentCell=z[1];\n        if(currentCell.state===VISITED) continue;\n        if(currentCell.key===dst.key)\n        {\n            visualQueue.push(currentCell.key);\n            currentCell.state=VISITED;\n            break;\n        }\n        currentCell.state=VISITED;\n        //currentCell.className=cssClasses.visited;\n        visualQueue.push(currentCell.key);\n        for(let a=0;a<r.length;a++) //or c.length\n        {\n            i=currentCell.i+r[a];\n            j=currentCell.j+c[a];\n            hashKey=i+'-'+j;\n            if(board[hashKey] && board[hashKey].state===UNVISITED)\n            {\n                // console.log('null path error:','previous:'+i+'-'+j,'current:'+hashKey,'cell:'+board[hashKey],'weight'+heuristics[i][j]);\n                queue.push([heuristics[i][j],board[hashKey]]);\n                previous[hashKey]=currentCell.i+'-'+currentCell.j;\n            }\n        }\n    }\n    let node=dst.key;\n    let path=[];\n    while(1)\n    {\n        if(node)\n        {\n            path.push(node);\n            board[node].state=PATH;\n            if(!previous[node]) break;\n            node=previous[node];\n            // console.log(node);\n            if(node===src.key)\n            {\n                path.push(node);\n                board[node].state=PATH;\n                break;\n            }\n        }\n        else break;\n    }\n    let grid=getGrid(board);\n    result=[visualQueue,path,grid];\n    // console.log('path',path);\n    // console.log('visualQueue',visualQueue);\n    return result;\n}\nfunction getGrid(board)\n{\n    let grid,row;\n    grid=[];\n    for(var i=0;i<MAX_ROW;i++)\n    {\n        row=[]\n        for(var j=0;j<MAX_COLUMN;j++)\n        {\n            row.push(board[i+'-'+j]);\n        }\n        grid.push(row);\n    }\n    return grid;\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/recursiveMaze.js",["182","183","184","185","186","187","188","189","190","191","192","193","194","195","196"],"import { VISITED,OBSTRUCTION,UNVISITED, MAX_COLUMN,MAX_ROW } from './GRAPH_CONSTANTS';\nexport function recursiveMaze(board,src,dst)\n{\n    let strKey;\n    let currentCell,i,j,hashKey;\n    let queue=[];\n    let visualQueue=[];\n    // for(var x=0;x<MAX_ROW;x++) addToQueue(x,0,board,visualQueue);\n    // for(var y=0;y<MAX_COLUMN;y++) addToQueue(MAX_ROW-1,y,board,visualQueue);\n    // for(var x=MAX_ROW;x>=0;x--) addToQueue(x,MAX_COLUMN-1,board,visualQueue);\n    // for(var y=MAX_COLUMN-1;y>=0;y--) addToQueue(0,y,board,visualQueue);\n    for(var p=0;p<MAX_ROW;p++)\n    {\n        for(var q=0;q<MAX_COLUMN;q++)\n        {\n            if(p%2===0 && q%2===0)\n            {\n                strKey=p+'-'+q;\n                //if(src.key===strKey || dst.key===strKey) continue;\n                //board[strKey].state=OBSTRUCTION\n                //board[strKey].className='cssClasses.obstruction';\n                addToQueue(p,q,board,visualQueue,src,dst);\n            }\n        }\n    }    \n    generateMaze(board,visualQueue,src,dst);\n    let previous={};\n    let result=[];\n    let grid=getGrid(board);\n    let r=[1,0]; //x,y x-1,y x+1,y x,y-1 x,y+1\n    let c=[0,1];\n    result=[board,visualQueue,grid];\n    return result;\n}\nfunction addToQueue(i,j,board,visualQueue,src,dst)\n{\nlet key=i+'-'+j;\nif(key==src.key || key==dst.key) return;\nboard[key].state=OBSTRUCTION;\nvisualQueue.push(key);\n//board[key].className='cssClasses.obstruction';\n}\nfunction generateMaze(board,visualQueue,src,dst)\n{\nlet key,num;\nfor(var p=0;p<MAX_ROW;p++)\n{\n    for(var q=0;q<MAX_COLUMN;q++)\n    {\n        key=board[p+'-'+q];\n        if(src.key===key || dst.key===key) continue;\n        if(p%2==0 && q%2==0)\n        {\n            num=(Math.random()*10);\n            if(num>=5){\n                if(q+1<MAX_COLUMN) addToQueue(p,q+1,board,visualQueue,src,dst);\n                num=(Math.random()*10);\n                if(num>=5){\n                    if(p+1<MAX_ROW) addToQueue(p+1,q,board,visualQueue,src,dst);\n                }    \n            }\n            else\n            {\n                if(p+1<MAX_ROW) addToQueue(p+1,q,board,visualQueue,src,dst);\n            }\n        }\n    }\n}\n\n\n}\n\nfunction getGrid(board)\n{\n    let grid,row;\n    grid=[];\n    for(var i=0;i<MAX_ROW;i++)\n    {\n        row=[]\n        for(var j=0;j<MAX_COLUMN;j++)\n        {\n            row.push(board[i+'-'+j]);\n        }\n        grid.push(row);\n    }\n    return grid;\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/bestFirstSearchWeighted.js",["197","198","199","200","201","202","203","204","205"],"import { VISITED,OBSTRUCTION,UNVISITED,PATH, MAX_COLUMN, MAX_ROW } from './GRAPH_CONSTANTS';\nimport PriorityQueue from './Utility/PriorityQueue';\nimport { getGrid } from './Utility/utility';\nexport function bestFirstSearchWeighted(src,board,dst,weightsBoard,heuristic)\n{\nconst pq=new PriorityQueue((a,b)=>{return a[0]<b[0]});\nconsole.log('src',src);\nconsole.log('dst',dst);\nconsole.log('board',board);\nlet currentCell,i,j,hashKey,pathWeight,weight;\nlet visualQueue=[];\nlet previous={};\nlet next={};\nlet result=[];\nlet weights={};\nlet visited={};\n\nlet grid=getGrid(board);\n\nlet neighbour;\nlet r=[-1,0,1,0]; //x,y x-1,y x+1,y x,y-1 x,y+1\nlet c=[0,-1,0,1];\nconsole.log('src:',src);\nconsole.log('dst:',dst);\nconsole.log('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')\npq.push([weightsBoard[src.i][src.j]+heuristic[src.i][src.j],src,heuristic[src.i][src.j]]);\n\n\nwhile(!pq.isEmpty())\n{\n    currentCell=pq.pop();\n    //visited[currentCell.i+'-'+currentCell.j]\n    if(currentCell[1].state==VISITED) continue;\n    currentCell[1].state=VISITED;\n    visualQueue.push(currentCell[1].key);\n    //weights[currentCell.i+'-'+currentCell.j]=currentCell;\n    if(currentCell[1].key==dst.key) break;\n    for(let a=0;a<r.length;a++){ // or c.length\n        i=currentCell[1].i+r[a];\n        j=currentCell[1].j+c[a];\n        //console.log('grid error',currentCell[1].i+r[a]);\n        if(i<0 || i>=MAX_ROW || j<0 || j>=MAX_COLUMN) continue;\n        neighbour=grid[currentCell[1].i+r[a]][currentCell[1].j+c[a]];\n        if(neighbour.state==VISITED || neighbour.state==OBSTRUCTION) continue;\n        pathWeight=currentCell[2]+weightsBoard[neighbour.i][neighbour.j]\n        pq.push([pathWeight+heuristic[neighbour.i][neighbour.j],neighbour,pathWeight]);\n        weight=previous[neighbour.key]?previous[neighbour.key][0]:Infinity;\n        if(weight>pathWeight) previous[neighbour.key]=[pathWeight,currentCell[1].key];\n    }\n\n}\n\nconsole.log(previous);\n\nlet node=dst.key;\nlet path=[];\nwhile(1)\n{\n    if(node)\n    {\n        path.push(node);\n        board[node].state=PATH;\n        if(!previous[node]) break;\n        node=previous[node][1];\n        console.log(node);\n        if(node===src.key)\n        {\n            path.push(node);\n            board[node].state=PATH;\n            break;\n        }\n    }\n    else break;\n}\n\n\n\nresult=[visualQueue,path,grid];\nconsole.log('path',path);\nconsole.log('visualQueue',visualQueue);\nreturn result;\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/dfs.js",["206","207","208","209"],"import { VISITED,OBSTRUCTION,UNVISITED,PATH, MAX_COLUMN, MAX_ROW } from './GRAPH_CONSTANTS';\nimport { getGrid } from './Utility/utility';\nexport function depthFirstSearch(src,board,dst)\n{\n    console.log('src',src);\n    console.log('dst',dst);\n    console.log('board',board);\n    let currentCell,i,j,hashKey;\n    let stack=[];\n    let visualQueue=[];\n    let previous={};\n    let result=[];\n    let r=[-1,0,1,0]; //x,y x-1,y x+1,y x,y-1 x,y+1\n    let c=[0,-1,0,1];\n    console.log('src:',src);\n    console.log('dst:',dst);\n    console.log('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')\n    stack.push(src);\n\n    while(stack.length!=0)\n    {\n        currentCell=stack.pop();\n        if(currentCell.state===VISITED) continue;\n        if(currentCell.key===dst.key)\n        {\n            visualQueue.push(currentCell.key);\n            currentCell.state=VISITED;\n            break;\n        }\n        currentCell.state=VISITED;\n        //currentCell.className=cssClasses.visited;\n        visualQueue.push(currentCell.key);\n        for(let a=0;a<r.length;a++) //or c.length\n        {\n            i=currentCell.i+r[a];\n            j=currentCell.j+c[a];\n            hashKey=i+'-'+j;\n            if(board[hashKey] && board[hashKey].state===UNVISITED)\n            {\n                stack.push(board[hashKey]);\n                previous[hashKey]=currentCell.i+'-'+currentCell.j;\n            }\n        }\n    }\n    let node=dst.key;\n    let path=[];\n    while(1)\n    {\n        if(node)\n        {\n            path.push(node);\n            board[node].state=PATH;\n            node=previous[node];\n            console.log(node);\n            if(node===src.key)\n            {\n                path.push(node);\n                board[node].state=PATH;\n                break;\n            }\n        }\n        else break;\n    }\n    let grid=getGrid(board);\n    result=[visualQueue,path,grid];\n    console.log('path',path);\n    console.log('visualQueue',visualQueue);\n    return result;\n\n\n    \n\n\n\n\n}\n","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/dfsMaze.js",["210","211","212","213","214","215","216","217"],"import { VISITED,OBSTRUCTION,UNVISITED, MAX_COLUMN,MAX_ROW, MAZE } from './GRAPH_CONSTANTS';\nexport function dfsMaze(board,src,dst)\n{\nlet grid=getGrid(board);\nlet visited=generateVisited();\nlet visualQueue;\n//visited[src.i][src.j]=true;\n//visited[dst.i][dst.j]=true;\nvisualQueue=dfs(board,MAZE.x,MAZE.y,visited,src,dst);\nlet result=[board,visualQueue,grid];\nreturn result;\n}\nfunction dfs(board,i,j,visited,src,dst)\n{\n    let visualQueue=[];\n    let stack=[];\n    stack.push([i,j]);\n    addToQueue(i,j,board,visualQueue,src,dst)\n    visited[i][j]=true;\n    let currentNode,steps,r,c,index,z,a,b;\n    while(stack.length!=0)\n    {\n        currentNode=stack.pop();\n        console.log('currentNode:',currentNode[0],currentNode[1]);\n        steps=[];\n        r=[-1,0,1,0];\n        c=[0,-1,0,1];\n        for(let x=0;x<r.length;x++) steps.push([r[x],c[x]]);\n        visit(board,currentNode[0],currentNode[1],steps,visualQueue,visited,src,dst);\n        index=0;\n        z=4;\n        console.log('traversing');\n        while(r.length>0)\n        {\n            index=(Math.floor(Math.random()*10))%z;\n            a=currentNode[0]+r[index]*2;\n            b=currentNode[1]+c[index]*2;\n            r.splice(index,1);\n            c.splice(index,1);\n            z--;\n            if(isValid(a,b,MAX_ROW,MAX_COLUMN) && visited[a][b]===false)\n            {\n                visited[a][b]=true;\n                stack.push([a,b]);\n            }\n        }\n    \n    }\n    return visualQueue;\n}\nfunction visit(board,i,j,steps,visualQueue,visited,src,dst){\n    let vi,vj,indexI,indexJ;\n    for(var q=0;q<steps.length;q++)\n    {\n\t\tindexI = i+steps[q][0];\n\t\tindexJ = j+steps[q][1];\n\t\tvi = i+steps[q][0]*2;\n\t\tvj = j+steps[q][1]*2;\n\t\tif(!isValid(indexI,indexJ,MAX_ROW,MAX_COLUMN)) continue;\n        if(isValid(vi,vj,MAX_ROW,MAX_COLUMN) && visited[vi][vj]===false)\n        {\n            addToQueue(indexI,indexJ,board,visualQueue,src,dst);\n            visited[indexI][indexJ]=true;\n            addToQueue(vi,vj,board,visualQueue,src,dst);\n        } \n    }\n}\n\nfunction isValid(i,j,maxR,maxC){\n\treturn (i>=0 && i<maxR && j>=0 && j<maxC);\n}\nfunction addToQueue(i,j,board,visualQueue,src,dst)\n{\nif((i==src.i && j==src.j) || (i==dst.i && j==dst.j)) return;\nlet key=i+'-'+j;\nboard[key].state=OBSTRUCTION;\nvisualQueue.push(key);\n//board[key].className='cssClasses.obstruction';\n}\nfunction getGrid(board)\n{\n    let grid,row;\n    grid=[];\n    for(var i=0;i<MAX_ROW;i++)\n    {\n        row=[]\n        for(var j=0;j<MAX_COLUMN;j++)\n        {\n            row.push(board[i+'-'+j]);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\nfunction generateVisited(){\n    let visited,row;\n    visited=[];\n    for(var i=0;i<MAX_ROW;i++)\n    {\n        row=[]\n        for(var j=0;j<MAX_COLUMN;j++)\n        {\n            row.push(false);\n        }\n        visited.push(row);\n    }\n    return visited;    \n}\nfunction test(visited){\n    var x='';\n    for(var p=0;p<visited.length;p++)\n    {\n        for(var q=0;q<visited[p].length;q++) x+=visited[p][q]+' ';\n        x+='\\n';\n    }\n    document.getElementById('testingTextArea').value=document.getElementById('testingTextArea').value+'\\n\\n\\n'+x;\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/randomObstructionMaze.js",["218","219","220","221","222","223","224","225","226","227","228","229","230"],"import { VISITED,OBSTRUCTION,UNVISITED, MAX_COLUMN,MAX_ROW } from './GRAPH_CONSTANTS';\nexport function randomObstructionMaze(board,src,dst)\n{\n    let strKey;\n    let currentCell,i,j,hashKey;\n    let queue=[];\n    let visualQueue=[];\n    // for(var x=0;x<MAX_ROW;x++) addToQueue(x,0,board,visualQueue);\n    // for(var y=0;y<MAX_COLUMN;y++) addToQueue(MAX_ROW-1,y,board,visualQueue);\n    // for(var x=MAX_ROW;x>=0;x--) addToQueue(x,MAX_COLUMN-1,board,visualQueue);\n    // for(var y=MAX_COLUMN-1;y>=0;y--) addToQueue(0,y,board,visualQueue);\n    for(var p=0;p<MAX_ROW;p++)\n    {\n        for(var q=0;q<MAX_COLUMN;q++)\n        {\n            strKey=p+'-'+q;\n            //if(src.key===strKey || dst.key===strKey) continue;\n            //board[strKey].state=OBSTRUCTION\n            //board[strKey].className='cssClasses.obstruction';\n            if(Math.floor(Math.random()*10)%4==0) addToQueue(p,q,board,visualQueue,src,dst);\n        }\n    }    \n    let result=[];\n    let grid=getGrid(board);\n    let r=[1,0]; //x,y x-1,y x+1,y x,y-1 x,y+1\n    let c=[0,1];\n    result=[board,visualQueue,grid];\n    return result;\n}\nfunction addToQueue(i,j,board,visualQueue,src,dst)\n{\nlet key=i+'-'+j;\nif(key==src.key || key==dst.key) return;\nboard[key].state=OBSTRUCTION;\nvisualQueue.push(key);\n//board[key].className='cssClasses.obstruction';\n}\n\nfunction getGrid(board)\n{\n    let grid,row;\n    grid=[];\n    for(var i=0;i<MAX_ROW;i++)\n    {\n        row=[]\n        for(var j=0;j<MAX_COLUMN;j++)\n        {\n            row.push(board[i+'-'+j]);\n        }\n        grid.push(row);\n    }\n    return grid;\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Grid/Helper.js",["231","232","233"],"import React, {Component} from 'react';\nimport cssClasses from './Grid.module.css';\nimport { UNVISITED,MAX_COLUMN,MAX_ROW } from './GRID_CONSTANTS';\nimport { OBSTRUCTION } from '../algorithms/GRAPH_CONSTANTS';\nexport function createBoard()\n{\n    let board=[];\n    let cells={};\n    let row,x;\n    for(let i=0;i<MAX_ROW;i++)\n    {\n        row=[];\n        for(let j=0;j<MAX_COLUMN;j++)\n        {\n            x={\n                i:i,\n                j:j,\n               state: UNVISITED,\n               key: i+'-'+j,\n               //className: 'cssClasses.unvisited'\n            };\n            cells[x.key]=x;\n            row.push(x);\n        }\n        board.push(row);\n    }\n    return [board,cells];\n}\n\nexport function createWeightBoard(){\n    let weightBoard=[];\n    let row,x;\n    for(let i=0;i<MAX_ROW;i++)\n    {\n        row=[];\n        for(let j=0;j<MAX_COLUMN;j++)\n        {\n            x=Math.floor(Math.random()*10)%10;\n            row.push(x);\n        }\n        weightBoard.push(row);\n    }\n    return weightBoard;\n\n}\nexport function createEmptyWeightBoard(){\n    let weightBoard=[];\n    let row,x;\n    for(let i=0;i<MAX_ROW;i++)\n    {\n        row=[];\n        for(let j=0;j<MAX_COLUMN;j++)\n        {\n            x=1;\n            row.push(x);\n        }\n        weightBoard.push(row);\n    }\n    return weightBoard;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexport function createClearedBoard(leaveObstruction,prevBoard){\n    let board=[];\n    let cells={};\n    let row,x;\n    for(let i=0;i<MAX_ROW;i++)\n    {\n        row=[];\n        for(let j=0;j<MAX_COLUMN;j++)\n        {\n            x={\n                i:i,\n                j:j,\n               state: (leaveObstruction && prevBoard[i][j].state===OBSTRUCTION)?OBSTRUCTION:UNVISITED,\n               key: i+'-'+j,\n               //className: 'cssClasses.unvisited'\n            };\n            cells[x.key]=x;\n            row.push(x);\n        }\n        board.push(row);\n    }\n    return [board,cells];\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/NavigationBar/NavigationBar.js",["234"],"import React, {Component} from 'react';\n\nexport default class NavigationBar extends Component{\n    state={\n        currentAlgorithm:'',\n        currentAlgorithmKey:-1,\n        currentMaze:'',\n        currentMazeKey:-1\n    }\n    algorithmSelectorHandler(key)\n    {\n        this.setState({\n            currentAlgorithm:this.props.algorithms[key],\n            currentAlgorithmKey:key    \n        })\n        this.props.algorithmHandler(key);\n    }\n    mazeSelectorHandler(key)\n    {\n        this.setState({\n            ...this.state,\n            currentMaze:this.props.mazes[key],\n            currentMazeKey:key\n        })\n        this.props.mazeHandler(key);\n    }\n    render()\n    {\n        let background_color='primary-color';\n        return (\n<nav className={\"navbar justify-content-center navbar-expand-lg navbar-dark \"+background_color} style={{}}>\n\n  <a className=\"navbar-brand\" href=\"#\"><h1><b><i className=\"fas fa-route\" style={{color:'green'}}></i> Path-Finder</b></h1></a>\n\n</nav>\n            );\n    }\n}","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/Legend/Legend.js",[],"/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/Utility/utility.js",["235","236","237","238"],"import { VISITED,OBSTRUCTION,UNVISITED,PATH, MAX_COLUMN, MAX_ROW } from '../GRAPH_CONSTANTS';\nexport function getGrid(board)\n{\n    let grid,row;\n    grid=[];\n    for(var i=0;i<MAX_ROW;i++)\n    {\n        row=[]\n        for(var j=0;j<MAX_COLUMN;j++)\n        {\n            row.push(board[i+'-'+j]);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\n//export default getGrid;","/home/ibrahim/work/github/path-finder-visualizer/path-finder-visualizer/src/Visualizer/algorithms/Utility/PriorityQueue.js",["239"],"const top = 0;\nconst parent = i => ((i + 1) >>> 1) - 1;\nconst left = i => (i << 1) + 1;\nconst right = i => (i + 1) << 1;\n\nexport default class PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this._heap = [];\n    this._comparator = comparator;\n  }\n  size() {\n    return this._heap.length;\n  }\n  isEmpty() {\n    return this.size() == 0;\n  }\n  peek() {\n    return this._heap[top];\n  }\n  push(...values) {\n    values.forEach(value => {\n      this._heap.push(value);\n      this._siftUp();\n    });\n    return this.size();\n  }\n  pop() {\n    const poppedValue = this.peek();\n    const bottom = this.size() - 1;\n    if (bottom > top) {\n      this._swap(top, bottom);\n    }\n    this._heap.pop();\n    this._siftDown();\n    return poppedValue;\n  }\n  replace(value) {\n    const replacedValue = this.peek();\n    this._heap[top] = value;\n    this._siftDown();\n    return replacedValue;\n  }\n  _greater(i, j) {\n    return this._comparator(this._heap[i], this._heap[j]);\n  }\n  _swap(i, j) {\n    [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];\n  }\n  _siftUp() {\n    let node = this.size() - 1;\n    while (node > top && this._greater(node, parent(node))) {\n      this._swap(node, parent(node));\n      node = parent(node);\n    }\n  }\n  _siftDown() {\n    let node = top;\n    while (\n      (left(node) < this.size() && this._greater(left(node), node)) ||\n      (right(node) < this.size() && this._greater(right(node), node))\n    ) {\n      let maxChild = (right(node) < this.size() && this._greater(right(node), left(node))) ? right(node) : left(node);\n      this._swap(node, maxChild);\n      node = maxChild;\n    }\n  }\n}",{"ruleId":"240","replacedBy":"241"},{"ruleId":"242","replacedBy":"243"},{"ruleId":"244","severity":1,"message":"245","line":2,"column":8,"nodeType":"246","messageId":"247","endLine":2,"endColumn":12},{"ruleId":"244","severity":1,"message":"248","line":4,"column":8,"nodeType":"246","messageId":"247","endLine":4,"endColumn":18},{"ruleId":"244","severity":1,"message":"249","line":2,"column":8,"nodeType":"246","messageId":"247","endLine":2,"endColumn":15},{"ruleId":"250","severity":1,"message":"251","line":38,"column":22,"nodeType":"252","messageId":"253","endLine":38,"endColumn":24},{"ruleId":"250","severity":1,"message":"251","line":38,"column":42,"nodeType":"252","messageId":"253","endLine":38,"endColumn":44},{"ruleId":"250","severity":1,"message":"251","line":51,"column":20,"nodeType":"252","messageId":"253","endLine":51,"endColumn":22},{"ruleId":"250","severity":1,"message":"251","line":51,"column":38,"nodeType":"252","messageId":"253","endLine":51,"endColumn":40},{"ruleId":"244","severity":1,"message":"254","line":63,"column":11,"nodeType":"246","messageId":"247","endLine":63,"endColumn":18},{"ruleId":"255","severity":1,"message":"256","line":68,"column":13,"nodeType":"257","endLine":68,"endColumn":152},{"ruleId":"258","severity":1,"message":"259","line":76,"column":19,"nodeType":"257","endLine":76,"endColumn":172},{"ruleId":"250","severity":1,"message":"251","line":76,"column":96,"nodeType":"252","messageId":"253","endLine":76,"endColumn":98},{"ruleId":"258","severity":1,"message":"259","line":102,"column":60,"nodeType":"257","endLine":102,"endColumn":195},{"ruleId":"250","severity":1,"message":"251","line":102,"column":111,"nodeType":"252","messageId":"253","endLine":102,"endColumn":113},{"ruleId":"244","severity":1,"message":"260","line":5,"column":8,"nodeType":"246","messageId":"247","endLine":5,"endColumn":14},{"ruleId":"244","severity":1,"message":"261","line":6,"column":33,"nodeType":"246","messageId":"247","endLine":6,"endColumn":41},{"ruleId":"250","severity":1,"message":"251","line":59,"column":89,"nodeType":"252","messageId":"253","endLine":59,"endColumn":91},{"ruleId":"244","severity":1,"message":"262","line":71,"column":13,"nodeType":"246","messageId":"247","endLine":71,"endColumn":20},{"ruleId":"244","severity":1,"message":"262","line":84,"column":13,"nodeType":"246","messageId":"247","endLine":84,"endColumn":20},{"ruleId":"250","severity":1,"message":"251","line":123,"column":219,"nodeType":"252","messageId":"253","endLine":123,"endColumn":221},{"ruleId":"250","severity":1,"message":"251","line":141,"column":42,"nodeType":"252","messageId":"253","endLine":141,"endColumn":44},{"ruleId":"244","severity":1,"message":"263","line":165,"column":13,"nodeType":"246","messageId":"247","endLine":165,"endColumn":16},{"ruleId":"244","severity":1,"message":"264","line":165,"column":22,"nodeType":"246","messageId":"247","endLine":165,"endColumn":27},{"ruleId":"244","severity":1,"message":"265","line":165,"column":32,"nodeType":"246","messageId":"247","endLine":165,"endColumn":33},{"ruleId":"244","severity":1,"message":"266","line":166,"column":13,"nodeType":"246","messageId":"247","endLine":166,"endColumn":18},{"ruleId":"244","severity":1,"message":"267","line":167,"column":9,"nodeType":"246","messageId":"247","endLine":167,"endColumn":13},{"ruleId":"244","severity":1,"message":"268","line":170,"column":13,"nodeType":"246","messageId":"247","endLine":170,"endColumn":16},{"ruleId":"244","severity":1,"message":"267","line":350,"column":9,"nodeType":"246","messageId":"247","endLine":350,"endColumn":13},{"ruleId":"244","severity":1,"message":"269","line":352,"column":13,"nodeType":"246","messageId":"247","endLine":352,"endColumn":24},{"ruleId":"244","severity":1,"message":"267","line":385,"column":9,"nodeType":"246","messageId":"247","endLine":385,"endColumn":13},{"ruleId":"244","severity":1,"message":"269","line":387,"column":13,"nodeType":"246","messageId":"247","endLine":387,"endColumn":24},{"ruleId":"244","severity":1,"message":"267","line":452,"column":9,"nodeType":"246","messageId":"247","endLine":452,"endColumn":13},{"ruleId":"244","severity":1,"message":"269","line":454,"column":13,"nodeType":"246","messageId":"247","endLine":454,"endColumn":24},{"ruleId":"244","severity":1,"message":"267","line":501,"column":9,"nodeType":"246","messageId":"247","endLine":501,"endColumn":13},{"ruleId":"244","severity":1,"message":"269","line":503,"column":13,"nodeType":"246","messageId":"247","endLine":503,"endColumn":24},{"ruleId":"244","severity":1,"message":"267","line":550,"column":9,"nodeType":"246","messageId":"247","endLine":550,"endColumn":13},{"ruleId":"244","severity":1,"message":"269","line":552,"column":13,"nodeType":"246","messageId":"247","endLine":552,"endColumn":24},{"ruleId":"270","severity":1,"message":"271","line":595,"column":21,"nodeType":"246","messageId":"272","endLine":595,"endColumn":22},{"ruleId":"270","severity":1,"message":"273","line":597,"column":25,"nodeType":"246","messageId":"272","endLine":597,"endColumn":26},{"ruleId":"244","severity":1,"message":"267","line":606,"column":9,"nodeType":"246","messageId":"247","endLine":606,"endColumn":13},{"ruleId":"244","severity":1,"message":"269","line":608,"column":13,"nodeType":"246","messageId":"247","endLine":608,"endColumn":24},{"ruleId":"244","severity":1,"message":"274","line":1,"column":18,"nodeType":"246","messageId":"247","endLine":1,"endColumn":29},{"ruleId":"250","severity":1,"message":"275","line":18,"column":23,"nodeType":"252","messageId":"253","endLine":18,"endColumn":25},{"ruleId":"244","severity":1,"message":"276","line":1,"column":30,"nodeType":"246","messageId":"247","endLine":1,"endColumn":39},{"ruleId":"244","severity":1,"message":"277","line":10,"column":21,"nodeType":"246","messageId":"247","endLine":10,"endColumn":28},{"ruleId":"244","severity":1,"message":"278","line":13,"column":5,"nodeType":"246","messageId":"247","endLine":13,"endColumn":9},{"ruleId":"244","severity":1,"message":"279","line":15,"column":5,"nodeType":"246","messageId":"247","endLine":15,"endColumn":12},{"ruleId":"244","severity":1,"message":"280","line":16,"column":5,"nodeType":"246","messageId":"247","endLine":16,"endColumn":12},{"ruleId":"250","severity":1,"message":"251","line":33,"column":28,"nodeType":"252","messageId":"253","endLine":33,"endColumn":30},{"ruleId":"250","severity":1,"message":"251","line":37,"column":26,"nodeType":"252","messageId":"253","endLine":37,"endColumn":28},{"ruleId":"250","severity":1,"message":"251","line":49,"column":27,"nodeType":"252","messageId":"253","endLine":49,"endColumn":29},{"ruleId":"250","severity":1,"message":"251","line":49,"column":55,"nodeType":"252","messageId":"253","endLine":49,"endColumn":57},{"ruleId":"250","severity":1,"message":"251","line":132,"column":24,"nodeType":"252","messageId":"253","endLine":132,"endColumn":26},{"ruleId":"244","severity":1,"message":"281","line":1,"column":10,"nodeType":"246","messageId":"247","endLine":1,"endColumn":17},{"ruleId":"244","severity":1,"message":"276","line":1,"column":30,"nodeType":"246","messageId":"247","endLine":1,"endColumn":39},{"ruleId":"270","severity":1,"message":"282","line":19,"column":13,"nodeType":"246","messageId":"272","endLine":19,"endColumn":14},{"ruleId":"270","severity":1,"message":"283","line":20,"column":13,"nodeType":"246","messageId":"272","endLine":20,"endColumn":14},{"ruleId":"244","severity":1,"message":"284","line":21,"column":33,"nodeType":"246","messageId":"247","endLine":21,"endColumn":37},{"ruleId":"244","severity":1,"message":"285","line":21,"column":38,"nodeType":"246","messageId":"247","endLine":21,"endColumn":42},{"ruleId":"244","severity":1,"message":"286","line":21,"column":43,"nodeType":"246","messageId":"247","endLine":21,"endColumn":50},{"ruleId":"244","severity":1,"message":"287","line":30,"column":5,"nodeType":"246","messageId":"247","endLine":30,"endColumn":12},{"ruleId":"250","severity":1,"message":"275","line":31,"column":23,"nodeType":"252","messageId":"253","endLine":31,"endColumn":25},{"ruleId":"250","severity":1,"message":"251","line":35,"column":24,"nodeType":"252","messageId":"253","endLine":35,"endColumn":26},{"ruleId":"250","severity":1,"message":"251","line":64,"column":13,"nodeType":"252","messageId":"253","endLine":64,"endColumn":15},{"ruleId":"250","severity":1,"message":"251","line":71,"column":13,"nodeType":"252","messageId":"253","endLine":71,"endColumn":15},{"ruleId":"250","severity":1,"message":"251","line":79,"column":6,"nodeType":"252","messageId":"253","endLine":79,"endColumn":8},{"ruleId":"250","severity":1,"message":"251","line":79,"column":18,"nodeType":"252","messageId":"253","endLine":79,"endColumn":20},{"ruleId":"250","severity":1,"message":"251","line":79,"column":32,"nodeType":"252","messageId":"253","endLine":79,"endColumn":34},{"ruleId":"250","severity":1,"message":"251","line":79,"column":44,"nodeType":"252","messageId":"253","endLine":79,"endColumn":46},{"ruleId":"244","severity":1,"message":"274","line":1,"column":18,"nodeType":"246","messageId":"247","endLine":1,"endColumn":29},{"ruleId":"244","severity":1,"message":"281","line":1,"column":10,"nodeType":"246","messageId":"247","endLine":1,"endColumn":17},{"ruleId":"244","severity":1,"message":"276","line":1,"column":30,"nodeType":"246","messageId":"247","endLine":1,"endColumn":39},{"ruleId":"244","severity":1,"message":"288","line":5,"column":9,"nodeType":"246","messageId":"247","endLine":5,"endColumn":20},{"ruleId":"244","severity":1,"message":"289","line":5,"column":21,"nodeType":"246","messageId":"247","endLine":5,"endColumn":22},{"ruleId":"244","severity":1,"message":"290","line":5,"column":23,"nodeType":"246","messageId":"247","endLine":5,"endColumn":24},{"ruleId":"244","severity":1,"message":"277","line":5,"column":25,"nodeType":"246","messageId":"247","endLine":5,"endColumn":32},{"ruleId":"244","severity":1,"message":"291","line":6,"column":9,"nodeType":"246","messageId":"247","endLine":6,"endColumn":14},{"ruleId":"244","severity":1,"message":"292","line":18,"column":17,"nodeType":"246","messageId":"247","endLine":18,"endColumn":23},{"ruleId":"244","severity":1,"message":"293","line":27,"column":9,"nodeType":"246","messageId":"247","endLine":27,"endColumn":17},{"ruleId":"244","severity":1,"message":"294","line":30,"column":9,"nodeType":"246","messageId":"247","endLine":30,"endColumn":10},{"ruleId":"244","severity":1,"message":"295","line":31,"column":9,"nodeType":"246","messageId":"247","endLine":31,"endColumn":10},{"ruleId":"250","severity":1,"message":"251","line":38,"column":7,"nodeType":"252","messageId":"253","endLine":38,"endColumn":9},{"ruleId":"250","severity":1,"message":"251","line":38,"column":23,"nodeType":"252","messageId":"253","endLine":38,"endColumn":25},{"ruleId":"250","severity":1,"message":"251","line":52,"column":15,"nodeType":"252","messageId":"253","endLine":52,"endColumn":17},{"ruleId":"250","severity":1,"message":"251","line":52,"column":25,"nodeType":"252","messageId":"253","endLine":52,"endColumn":27},{"ruleId":"244","severity":1,"message":"276","line":1,"column":30,"nodeType":"246","messageId":"247","endLine":1,"endColumn":39},{"ruleId":"244","severity":1,"message":"277","line":10,"column":21,"nodeType":"246","messageId":"247","endLine":10,"endColumn":28},{"ruleId":"244","severity":1,"message":"278","line":13,"column":5,"nodeType":"246","messageId":"247","endLine":13,"endColumn":9},{"ruleId":"244","severity":1,"message":"279","line":15,"column":5,"nodeType":"246","messageId":"247","endLine":15,"endColumn":12},{"ruleId":"244","severity":1,"message":"280","line":16,"column":5,"nodeType":"246","messageId":"247","endLine":16,"endColumn":12},{"ruleId":"250","severity":1,"message":"251","line":33,"column":28,"nodeType":"252","messageId":"253","endLine":33,"endColumn":30},{"ruleId":"250","severity":1,"message":"251","line":37,"column":26,"nodeType":"252","messageId":"253","endLine":37,"endColumn":28},{"ruleId":"250","severity":1,"message":"251","line":44,"column":27,"nodeType":"252","messageId":"253","endLine":44,"endColumn":29},{"ruleId":"250","severity":1,"message":"251","line":44,"column":55,"nodeType":"252","messageId":"253","endLine":44,"endColumn":57},{"ruleId":"244","severity":1,"message":"274","line":1,"column":18,"nodeType":"246","messageId":"247","endLine":1,"endColumn":29},{"ruleId":"244","severity":1,"message":"296","line":1,"column":46,"nodeType":"246","messageId":"247","endLine":1,"endColumn":56},{"ruleId":"244","severity":1,"message":"297","line":1,"column":58,"nodeType":"246","messageId":"247","endLine":1,"endColumn":65},{"ruleId":"250","severity":1,"message":"275","line":20,"column":23,"nodeType":"252","messageId":"253","endLine":20,"endColumn":25},{"ruleId":"244","severity":1,"message":"281","line":1,"column":10,"nodeType":"246","messageId":"247","endLine":1,"endColumn":17},{"ruleId":"244","severity":1,"message":"276","line":1,"column":30,"nodeType":"246","messageId":"247","endLine":1,"endColumn":39},{"ruleId":"250","severity":1,"message":"275","line":21,"column":23,"nodeType":"252","messageId":"253","endLine":21,"endColumn":25},{"ruleId":"250","severity":1,"message":"251","line":74,"column":6,"nodeType":"252","messageId":"253","endLine":74,"endColumn":8},{"ruleId":"250","severity":1,"message":"251","line":74,"column":18,"nodeType":"252","messageId":"253","endLine":74,"endColumn":20},{"ruleId":"250","severity":1,"message":"251","line":74,"column":32,"nodeType":"252","messageId":"253","endLine":74,"endColumn":34},{"ruleId":"250","severity":1,"message":"251","line":74,"column":44,"nodeType":"252","messageId":"253","endLine":74,"endColumn":46},{"ruleId":"244","severity":1,"message":"298","line":109,"column":10,"nodeType":"246","messageId":"247","endLine":109,"endColumn":14},{"ruleId":"244","severity":1,"message":"281","line":1,"column":10,"nodeType":"246","messageId":"247","endLine":1,"endColumn":17},{"ruleId":"244","severity":1,"message":"276","line":1,"column":30,"nodeType":"246","messageId":"247","endLine":1,"endColumn":39},{"ruleId":"244","severity":1,"message":"288","line":5,"column":9,"nodeType":"246","messageId":"247","endLine":5,"endColumn":20},{"ruleId":"244","severity":1,"message":"289","line":5,"column":21,"nodeType":"246","messageId":"247","endLine":5,"endColumn":22},{"ruleId":"244","severity":1,"message":"290","line":5,"column":23,"nodeType":"246","messageId":"247","endLine":5,"endColumn":24},{"ruleId":"244","severity":1,"message":"277","line":5,"column":25,"nodeType":"246","messageId":"247","endLine":5,"endColumn":32},{"ruleId":"244","severity":1,"message":"291","line":6,"column":9,"nodeType":"246","messageId":"247","endLine":6,"endColumn":14},{"ruleId":"244","severity":1,"message":"292","line":16,"column":13,"nodeType":"246","messageId":"247","endLine":16,"endColumn":19},{"ruleId":"250","severity":1,"message":"251","line":20,"column":46,"nodeType":"252","messageId":"253","endLine":20,"endColumn":48},{"ruleId":"244","severity":1,"message":"294","line":25,"column":9,"nodeType":"246","messageId":"247","endLine":25,"endColumn":10},{"ruleId":"244","severity":1,"message":"295","line":26,"column":9,"nodeType":"246","messageId":"247","endLine":26,"endColumn":10},{"ruleId":"250","severity":1,"message":"251","line":33,"column":7,"nodeType":"252","messageId":"253","endLine":33,"endColumn":9},{"ruleId":"250","severity":1,"message":"251","line":33,"column":23,"nodeType":"252","messageId":"253","endLine":33,"endColumn":25},{"ruleId":"244","severity":1,"message":"299","line":1,"column":8,"nodeType":"246","messageId":"247","endLine":1,"endColumn":13},{"ruleId":"244","severity":1,"message":"300","line":1,"column":16,"nodeType":"246","messageId":"247","endLine":1,"endColumn":25},{"ruleId":"244","severity":1,"message":"301","line":2,"column":8,"nodeType":"246","messageId":"247","endLine":2,"endColumn":18},{"ruleId":"258","severity":1,"message":"302","line":33,"column":3,"nodeType":"257","endLine":33,"endColumn":40},{"ruleId":"244","severity":1,"message":"281","line":1,"column":10,"nodeType":"246","messageId":"247","endLine":1,"endColumn":17},{"ruleId":"244","severity":1,"message":"274","line":1,"column":18,"nodeType":"246","messageId":"247","endLine":1,"endColumn":29},{"ruleId":"244","severity":1,"message":"276","line":1,"column":30,"nodeType":"246","messageId":"247","endLine":1,"endColumn":39},{"ruleId":"244","severity":1,"message":"303","line":1,"column":40,"nodeType":"246","messageId":"247","endLine":1,"endColumn":44},{"ruleId":"250","severity":1,"message":"251","line":15,"column":24,"nodeType":"252","messageId":"253","endLine":15,"endColumn":26},"no-native-reassign",["304"],"no-negated-in-lhs",["305"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'Visualizer' is defined but never used.","'Toolbar' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'setters' is assigned a value but never used.","react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" is a security risk: see https://html.spec.whatwg.org/multipage/links.html#link-type-noopener","JSXOpeningElement","jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","'Legend' is defined but never used.","'VISITING' is defined but never used.","'prevKey' is assigned a value but never used.","'key' is defined but never used.","'cells' is defined but never used.","'x' is defined but never used.","'board' is defined but never used.","'grid' is assigned a value but never used.","'row' is assigned a value but never used.","'afterUpdate' is assigned a value but never used.","no-redeclare","'r' is already defined.","redeclared","'c' is already defined.","'OBSTRUCTION' is defined but never used.","Expected '!==' and instead saw '!='.","'UNVISITED' is defined but never used.","'hashKey' is defined but never used.","'next' is assigned a value but never used.","'weights' is assigned a value but never used.","'visited' is assigned a value but never used.","'VISITED' is defined but never used.","'x' is already defined.","'y' is already defined.","'mid1' is defined but never used.","'mid2' is defined but never used.","'opening' is defined but never used.","'counter' is assigned a value but never used.","'currentCell' is defined but never used.","'i' is defined but never used.","'j' is defined but never used.","'queue' is assigned a value but never used.","'strKey' is assigned a value but never used.","'previous' is assigned a value but never used.","'r' is assigned a value but never used.","'c' is assigned a value but never used.","'MAX_COLUMN' is defined but never used.","'MAX_ROW' is defined but never used.","'test' is defined but never used.","'React' is defined but never used.","'Component' is defined but never used.","'cssClasses' is defined but never used.","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","'PATH' is defined but never used.","no-global-assign","no-unsafe-negation"]